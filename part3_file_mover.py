#!/usr/bin/env python3
"""
part3_file_mover.py

Move and/or rename files according to an ID‑based mapping that was
generated by the LLM organiser pipeline (Parts 1–2).

INPUTS
------
--file-list   JSON from Part 1‑1 (list of {"id", "path"} objects)
--mapping     JSON from Part 2   (list of {"id", "new_name", "new_path"} objects)
--root        Root directory where the original files currently reside
--dest-root   Destination root for the reorganised tree
              (defaults to --root; can be identical for in‑place moves)
--dry-run     If supplied, only prints the planned operations.

Each mapping entry tells us: move the file with *id* to
    {dest_root}/{new_path}/{new_name}

The script creates any missing directories, checks for collisions,
and logs a summary at the end.

EXAMPLE
-------
$ python part3_file_mover.py \
    --file-list file_list.json \
    --mapping mapping.json \
    --root ~/Downloads \
    --dest-root ~/Organised \
    --dry-run

DEPENDENCIES
------------
Python 3.8+, standard library only.
"""
from __future__ import annotations

import argparse
import json
import logging
import os
import shutil
import sys
from pathlib import Path
from typing import Dict, List

logging.basicConfig(
    level=logging.INFO,
    format="%(levelname)s: %(message)s",
)

###############################################################################
# Utility functions
###############################################################################


def load_json(path: str | Path) -> List[dict]:
    """Load a JSON file and return the parsed object."""
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except FileNotFoundError:
        logging.error("JSON file not found: %s", path)
        sys.exit(1)
    except json.JSONDecodeError as e:
        logging.error("Failed to parse JSON %s: %s", path, e)
        sys.exit(1)


def build_lookup(file_list: List[dict]) -> Dict[int, str]:
    """Return {id: relative_path} dict, validating uniqueness."""
    lookup: Dict[int, str] = {}
    for entry in file_list:
        fid = entry.get("id")
        rel_path = entry.get("path")
        if fid is None or rel_path is None:
            logging.error("Invalid file_list entry: %s", entry)
            sys.exit(1)
        if fid in lookup:
            logging.error("Duplicate id %s in file_list", fid)
            sys.exit(1)
        lookup[fid] = rel_path
    return lookup


def perform_move(
    src_root: Path,
    dest_root: Path,
    id_to_path: Dict[int, str],
    mapping: List[dict],
    dry_run: bool = False,
) -> None:
    """Move or rename each file according to mapping."""
    moved = 0
    skipped = 0
    for entry in mapping:
        fid = entry.get("id")
        new_name = entry.get("new_name")
        new_path = entry.get("new_path", "")  # allow empty for root
        if fid is None:
            logging.warning("Mapping entry missing id: %s", entry)
            skipped += 1
            continue
        if fid not in id_to_path:
            logging.warning("Unknown id %s in mapping; skipping.", fid)
            skipped += 1
            continue

        src_rel = id_to_path[fid]
        src = src_root / src_rel
        # Determine destination path
        dest_dir = (dest_root / new_path).resolve()
        dest_dir.mkdir(parents=True, exist_ok=True)
        dest_filename = new_name if new_name else src.name
        dest = dest_dir / dest_filename

        # Collision detection
        if dest.exists():
            logging.warning("Destination already exists: %s; skipping.", dest)
            skipped += 1
            continue

        if dry_run:
            logging.info("[dry‑run] %s -> %s", src, dest)
        else:
            logging.info("Moving %s -> %s", src, dest)
            try:
                shutil.move(str(src), str(dest))
                moved += 1
            except Exception as e:
                logging.error("Failed to move %s: %s", src, e)
                skipped += 1

    logging.info("Done. Moved %d files, skipped %d.", moved, skipped)


###############################################################################
# CLI
###############################################################################

def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(
        description="Part 3: Construct the new folder structure and move files."
    )
    p.add_argument("--file-list", required=True, help="JSON from Part 1‑1")
    p.add_argument("--mapping", required=True, help="JSON from Part 2")
    p.add_argument(
        "--root",
        required=True,
        help="Root directory where original files currently reside",
    )
    p.add_argument(
        "--dest-root",
        default=None,
        help="Destination root for organised files (default: same as --root)",
    )
    p.add_argument(
        "--dry-run",
        action="store_true",
        help="Print operations without making changes",
    )
    return p.parse_args()


def organize_and_move_files(file_list_path: str, mapping_path: str, root: str, dest_root: str = None, dry_run: bool = False) -> None:
    src_root = Path(root).resolve()
    dest_root = Path(dest_root).resolve() if dest_root else src_root

    if not src_root.exists():
        logging.error("Source root does not exist: %s", src_root)
        sys.exit(1)
    if not dest_root.exists():
        # Allow creating if not dry‑run
        if dry_run:
            logging.info(
                "[dry‑run] Would create destination root %s", dest_root)
        else:
            dest_root.mkdir(parents=True)

    file_list = load_json(file_list_path)
    mapping = load_json(mapping_path)

    id_to_path = build_lookup(file_list)
    perform_move(src_root, dest_root, id_to_path, mapping, dry_run)


if __name__ == "__main__":
    args = parse_args()
    organize_and_move_files(args.file_list, args.mapping,
                            args.root, args.dest_root, args.dry_run)
